<html>
<head>
  <script class="jsbin" src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta content="en-us" http-equiv="Content-Language">
	<meta content="lasers" name="keywords">
	<meta content="Cats... with lasers... in space." name="description">
  <title>LaserCat VI</title>
  <style type="text/css">
    html {
		  width: 100%;
		  height: 100%;
      margin:  0px auto;
      padding: 0px auto;
      overflow: hidden;
    }
    body {
      background-image:url('spacelarge.jpg');
      background-repeat: repeat;
      width: 100%;
      height: 100%;
      margin:  0px auto;
      padding: 0px auto;
      overflow: hidden;
    }
    #cat {
      position: absolute;
      background: none;
      width: 546px;
      height: 542px;
      bottom: 0px;
      right: 0px;
      z-index: -1;
      margin:  0px auto;
      padding: 0px auto;
    }
    #canvas{
      display:block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="cat"></div>
<script>
  (function(){

    //shim layer with setTimeout fallback to ensure cross-browser compatibility
  	window.requestAFrame = (function(){
  		return  window.requestAnimationFrame       ||
  			window.webkitRequestAnimationFrame ||
  			window.mozRequestAnimationFrame    ||
  			window.oRequestAnimationFrame      ||
  			window.msRequestAnimationFrame     ||
  		function(/* function */ callback, /* DOM Element */ element){
  						return window.setTimeout(callback, 1000 / 60);
  		};
  	  })();
      //the same for cancelAnimationFrameRequest
  	  window.cancelFrameRequest = (function(){
  		return window.cancelAnimationFrame            ||
  			window.webkitCancelRequestAnimationFrame    ||
  			window.mozCancelRequestAnimationFrame         ||
  			window.oCancelRequestAnimationFrame        ||
  			window.msCancelRequestAnimationFrame        ||
  		clearTimeout;
  	  })();

    //declare variables
    var
      canvas,
      context,
      catEyeL,
      catEyeR,
      lerpCalcL,
      lerpCalcR,
      laserTarget,
      ratPos,
      catPos,
      catBox,
      laserTarget;
    var request = null;
    var rate = 0;

    //create cat image object, define source
    var cat = new Image();
      cat.onLoad = function(){
        context.drawImage(this, 0,0);
      };
      cat.src = "cat.gif";

    //create rat image object, define source
    var rat = new Image();
      rat.onLoad = function(){
        context.drawImage(this, 0,0);
      };
      rat.src = "smspacerat.png";

    //on page load, ensuring canvas dimensions fill browser window BEFORE cat and rat images are drawn, while preventing drawCat(); and drawRat(); until image objects have loaded.
    window.onload = function() {
      canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      context = canvas.getContext("2d");
      drawCat();
      drawRat();
      };

    //attach event listener to window triggering canvas redraw on window resize (drawing must be done from resizeCanvas function)
    window.addEventListener('resize', resizeCanvas, false);

    //attach event listener to canvas triggering laser animation to mouse coordinates on click. We call animate instead of drawLasers(); to ensure the rat remains drawn.
    document.getElementById("canvas").addEventListener("click", function(e){
        //informing the variable we declared earlier, which will be used by drawLasers();
        laserTarget = {x:e.clientX,y:e.clientY}
        console.log("Laser Target - x: "+laserTarget.x+", y: "+laserTarget.y);
        animate();
      }, true);

    function drawCat(){
      catPos = {x:canvas.width-546, y:canvas.height-542};
      context.drawImage(cat, catPos.x,catPos.y, 546,542);
    }

    function drawRat(){
      ratPos = {x:canvas.width/3, y:canvas.height/3};
      context.drawImage(rat, ratPos.x,ratPos.y, 100,104);
    }

    function drawLasers(){

      //assign values needed for calculating laser origins
      catBox = document.getElementById('cat').getBoundingClientRect();
      catEyeL = {x:catBox.right-322,y:catBox.bottom-240};
      catEyeR = {x:catBox.right-179,y:catBox.bottom-219};

      //rate acts as a coefficient in our lerp math to affect the "speed" with which the laser appears to reach the target.
      rate += .05;
  		if (rate > 1) rate =1;

      //redraw cat before firing lasers to achieve the effect of firing from the eye of the cat (rather than behind, or clearing the cat altogether)
      catPos = {x:canvas.width-546, y:canvas.height-542};
      context.drawImage(cat, catPos.x,catPos.y, 546,542);

      //---DRAWING FROM LEFT CAT EYE TO MOUSE CLICK---//
      // to achieve a "laser-like" appearance, the line is stroked 3 times, each narrower in width and lighter in color.
      context.lineWidth=20;
      context.strokeStyle="red";
      context.lineCap="round";
      context.beginPath();
      context.moveTo(catEyeL.x,catEyeL.y);
      //instead of the line instantly appearing from the eye to the click event, we want a gradual, but predictable animation speed to further heighten the effect of the lasers "firing"
      //lerpCalcL and lerpCalcR apply interpolation math informing the nodes connected between each frame request during animation. The farther the target is away (the longer the line), the more quickly the laser is drawn.
      lerpCalcL = {
          x: catEyeL.x + (laserTarget.x - catEyeL.x) * rate,
          y: catEyeL.y + (laserTarget.y - catEyeL.y) * rate
      };
      context.lineTo(lerpCalcL.x,lerpCalcL.y);
      context.stroke();
      //since we have already calculated our first laserbeam (left eye to mouseclick), we need not re-define prior to drawing overlaying strokes of the same laser.
      context.lineWidth=12;
  		context.strokeStyle="#ff6363";
  		context.lineCap="round";
  		context.stroke();
  		context.lineWidth=5;
  		context.strokeStyle="white";
  		context.lineCap="round";
  		context.stroke();

      //---DRAWING FROM RIGHT CAT EYE TO MOUSE CLICK---//
      //need to re-set our stroke style--may be more idiomatic to save context after first stroke from the previous eye--haven't looked yet.
      context.lineWidth=20;
      context.strokeStyle="red";
      context.lineCap="round";
      // context.beginPath();<--commented out to prevent left laser from being drawn behind the right laser, which ruins the effect if the target is to the right of the cat image.
      context.moveTo(catEyeR.x,catEyeR.y);
      lerpCalcR = {
          x: catEyeR.x + (laserTarget.x - catEyeR.x) * rate,
          y: catEyeR.y + (laserTarget.y - catEyeR.y) * rate
      };
      context.lineTo(lerpCalcR.x,lerpCalcR.y);
      context.stroke();
      context.lineWidth=12;
  		context.strokeStyle="#ff6363";
  		context.lineCap="round";
  		context.stroke();
  		context.lineWidth=5;
  		context.strokeStyle="white";
  		context.lineCap="round";
  		context.stroke();

      //--CHECKING TO SEE IF LASERS HAVE REACHED TARGET BEFORE STOPPING ANIMATION--//
      // if statement stops laser animation once stroke reaches mouseclick event x & y--only need to measure from one eye
      if(lerpCalcL.x === laserTarget.x && lerpCalcL.y === laserTarget.y){
        context.save();
        cancelFrameRequest(request)
        console.log('Shots fired!!');
			  request = null;
			  rate = 0;
      }
    }

    function animate(){

      context.clearRect(0, 0, canvas.width, canvas.height);
      request = requestAFrame(animate, canvas);

      //NOTE:cat must be drawn from the drawLasers function to prevent being cleared (by calling drawCat(); before drawLasers();) or being drawn on top of the lasers (by calling drawLasers(); before drawCat();).
      drawLasers();
      drawRat();
    }

    function resizeCanvas() {

      //adjust canvas dimensions on window resize
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      //we don't want to draw the lasers on resize to avoid the erratic appearance--though it does work--there would be no benefit to "shooting" while resizing the browser window
      drawCat();
      drawRat();
    }

})();
</script>
</body>
</html>
